<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Algorithms | Knuth–Morris–Pratt algorithm</title>
      <link href="2021/04/24/kmp/"/>
      <url>2021/04/24/kmp/</url>
      
        <content type="html"><![CDATA[<p>In this article we talk abount KMP algorithm</p><p><strong>Let’s define a statement:</strong></p><p>Find all occurrence of pattern in string. </p><p>By using naive approach we get answer of <code>O(m * n)</code> complexity, where  <code>n</code> - length of text and <code>m</code> - length of pattern. However applying KMP algorithm, this could be done of <code>O(m + n)</code> asymptotic complexity and <code>O(m)</code> space complexity. </p><p>Algorithm:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Kmp</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        String text = <span class="string">"ABDAABAABCCDVCABCADEEQAAA"</span>;</span><br><span class="line">        String pattern = <span class="string">"ABCA"</span>;</span><br><span class="line">        search(text, pattern);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">(String text, String pattern)</span> </span>{</span><br><span class="line">        System.out.format(<span class="string">"Search [%s] in [%s]%n"</span>, pattern, text);</span><br><span class="line">        <span class="keyword">int</span> [] lps = computeTable(pattern);</span><br><span class="line">        <span class="keyword">int</span> textIndex = <span class="number">0</span>, textLen = text.length();</span><br><span class="line">        <span class="keyword">int</span> patternIndex = <span class="number">0</span>, patternLen = pattern.length();</span><br><span class="line">        <span class="keyword">while</span>(textIndex &lt; textLen) {</span><br><span class="line">            <span class="comment">// match case</span></span><br><span class="line">            <span class="keyword">if</span> (text.charAt(textIndex) == pattern.charAt(patternIndex)) {</span><br><span class="line">                ++textIndex;</span><br><span class="line">                ++patternIndex;</span><br><span class="line">            } </span><br><span class="line">            <span class="keyword">if</span> (patternIndex == patternLen) {</span><br><span class="line">                <span class="comment">// find pattern in text</span></span><br><span class="line">                System.out.format(<span class="string">"Find match at index %s%n"</span>,textIndex - patternLen);</span><br><span class="line">                patternIndex = lps[patternIndex - <span class="number">1</span>];</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (textIndex &lt; textLen &amp;&amp; pattern.charAt(patternIndex) != text.charAt(textIndex)) {</span><br><span class="line">                <span class="comment">// mismatch case</span></span><br><span class="line">                <span class="keyword">if</span> (patternIndex != <span class="number">0</span>) {</span><br><span class="line">                    <span class="comment">// go to prev precomputed value</span></span><br><span class="line">                    patternIndex = lps[patternIndex - <span class="number">1</span>];</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    ++textIndex;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] computeTable(String pattern) {</span><br><span class="line">        <span class="keyword">int</span> m = pattern.length();</span><br><span class="line">        <span class="keyword">int</span> [] lps = <span class="keyword">new</span> <span class="keyword">int</span> [m];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(index &lt; m) {</span><br><span class="line">            <span class="keyword">if</span> (pattern.charAt(index) == pattern.charAt(len)) {</span><br><span class="line">                lps[index++] = ++len;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">if</span> (len != <span class="number">0</span>) {</span><br><span class="line">                    len = lps[len - <span class="number">1</span>];</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    ++index;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> lps;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>Main idea is next:</p><ol><li>Pre compute longest proper prefix which is also suffix(<code>lps</code>)</li><li>Define <code>textIndex, patternIndex</code> as iteration values in cycle</li><li>Iterate in text and do comparison between corresponding indexes of text and pattern:<ol><li>If match case, increment both indexes of text and pattern</li><li>In case when index of pattern equals to lenth of pattern, it means we finded a match</li><li>In another case decrement corresponding index of pattern until we find a match or it will become a zero. In zero case increment text index</li></ol></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Url shortener</title>
      <link href="2021/04/03/url-shortener/"/>
      <url>2021/04/03/url-shortener/</url>
      
        <content type="html"><![CDATA[<p>Checkout my url shortener service <a href="https://github.com/AbdybaevAE/Url-Shortener">here.</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Latency Numbers Every Programmer Should Know</title>
      <link href="2021/03/17/speed-table/"/>
      <url>2021/03/17/speed-table/</url>
      
        <content type="html"><![CDATA[<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Latency Comparison Numbers (~2012)</span><br><span class="line">----------------------------------</span><br><span class="line">L1 cache reference                           0.5 ns</span><br><span class="line">Branch mispredict                            5   ns</span><br><span class="line">L2 cache reference                           7   ns                      14x L1 cache</span><br><span class="line">Mutex lock/unlock                           25   ns</span><br><span class="line">Main memory reference                      100   ns                      20x L2 cache, 200x L1 cache</span><br><span class="line">Compress 1K bytes with Zippy             3,000   ns        3 us</span><br><span class="line">Send 1K bytes over 1 Gbps network       10,000   ns       10 us</span><br><span class="line">Read 4K randomly from SSD*             150,000   ns      150 us          ~1GB/sec SSD</span><br><span class="line">Read 1 MB sequentially from memory     250,000   ns      250 us</span><br><span class="line">Round trip within same datacenter      500,000   ns      500 us</span><br><span class="line">Read 1 MB sequentially from SSD*     1,000,000   ns    1,000 us    1 ms  ~1GB/sec SSD, 4X memory</span><br><span class="line">Disk seek                           10,000,000   ns   10,000 us   10 ms  20x datacenter roundtrip</span><br><span class="line">Read 1 MB sequentially from disk    20,000,000   ns   20,000 us   20 ms  80x memory, 20X SSD</span><br><span class="line">Send packet CA-&gt;Netherlands-&gt;CA    150,000,000   ns  150,000 us  150 ms</span><br><span class="line"></span><br><span class="line">Notes</span><br><span class="line">-----</span><br><span class="line">1 ns = 10^-9 seconds</span><br><span class="line">1 us = 10^-6 seconds = 1,000 ns</span><br><span class="line">1 ms = 10^-3 seconds = 1,000 us = 1,000,000 ns</span><br><span class="line"></span><br><span class="line">Credit</span><br><span class="line">------</span><br><span class="line">By Jeff Dean:               http://research.google.com/people/jeff/</span><br><span class="line">Originally by Peter Norvig: http://norvig.com/21-days.html#answers</span><br><span class="line"></span><br><span class="line">Contributions</span><br><span class="line">-------------</span><br><span class="line">&#x27;Humanized&#x27; comparison:  https://gist.github.com/hellerbarde/2843375</span><br><span class="line">Visual comparison chart: http://i.imgur.com/k0t1e.png</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Design Patterns | Adapter</title>
      <link href="2021/03/15/golang-design-patterns-adapter/"/>
      <url>2021/03/15/golang-design-patterns-adapter/</url>
      
        <content type="html"><![CDATA[<p><strong>Structural</strong> pattern - <strong>Adapter</strong></p><p>It allows you to connect objects with different interfaces. </p><p>Use cases:</p><ul><li>When you have existing classes, but its’ interfaces isn’t compatible with your code </li></ul><p>Let’s imagine next situation: </p><p>You wanna stream your computer desktop(with VGA OUTPUT) on TV. You only have VGA connector. In case if your TV compatible with VGA you just need to plug in connector, otherwise you need to get an adapter which convert all your computer signals to proper destination. </p><ol><li>Define <code>VGAClient</code>. In this case this will be your connector with VGA output </li><li>Define two types of devices that support VGA and HDMI Inputs</li><li>Define two concrete classes of <code>VGADevice and HDMIDevice</code></li><li>Create and adapter that accepts hdmi signal and convert it to VGA</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> VgaClient <span class="keyword">struct</span>{}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *VgaClient)</span> <span class="title">plugVgaToDevice</span><span class="params">(d VgaDevice)</span></span> {</span><br><span class="line">d.acceptVgaConnector()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> VgaDevice <span class="keyword">interface</span> {</span><br><span class="line">acceptVgaConnector()</span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> HdmiDevice <span class="keyword">interface</span> {</span><br><span class="line">acceptHdmiConnector()</span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> VgaDisplay <span class="keyword">struct</span>{}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *VgaDisplay)</span> <span class="title">acceptVgaConnector</span><span class="params">()</span></span> {</span><br><span class="line">fmt.Println(<span class="string">"Accepted vga connector"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HdmiDisplay <span class="keyword">struct</span>{}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *HdmiDisplay)</span> <span class="title">acceptHdmiConnector</span><span class="params">()</span></span> {</span><br><span class="line">fmt.Println(<span class="string">"Accept hdmi connector"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HdmiToVgaAdapter <span class="keyword">struct</span> {</span><br><span class="line">device VgaDevice</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HdmiToVgaAdapter)</span> <span class="title">acceptHdmiConnector</span><span class="params">()</span></span> {</span><br><span class="line"><span class="comment">// convert signal from HDMI to VGA</span></span><br><span class="line">h.device.acceptVgaConnector()</span><br><span class="line">}</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Design Patterns | Abstract Factory</title>
      <link href="2021/03/15/go-design-patterns-abstract-factory/"/>
      <url>2021/03/15/go-design-patterns-abstract-factory/</url>
      
        <content type="html"><![CDATA[<p><strong>Creational</strong> pattern - <strong>Abstract Factory</strong></p><p>Use cases:</p><ul><li>when you need to work with related classes while decoupling it on concrete classes </li><li>Consumer of your factory can easily use your factory methods and do not worry about compatibility of objects from different sub types </li></ul><p>Example: </p><p>Define <code>iShirt and shirt</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abstract_factory</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> iShirt <span class="keyword">interface</span> {</span><br><span class="line">Size() <span class="keyword">int</span></span><br><span class="line">SetSize(size <span class="keyword">int</span>)</span><br><span class="line">Logo() <span class="keyword">string</span></span><br><span class="line">SetLogo(logo <span class="keyword">string</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> shirt <span class="keyword">struct</span> {</span><br><span class="line">logo <span class="keyword">string</span></span><br><span class="line">size <span class="keyword">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *shirt)</span> <span class="title">SetLogo</span><span class="params">(logo <span class="keyword">string</span>)</span></span> {</span><br><span class="line">s.logo = logo</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *shirt)</span> <span class="title">Logo</span><span class="params">()</span> <span class="title">string</span></span> {</span><br><span class="line"><span class="keyword">return</span> s.logo</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *shirt)</span> <span class="title">SetSize</span><span class="params">(size <span class="keyword">int</span>)</span></span> {</span><br><span class="line">s.size = size</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *shirt)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">int</span></span> {</span><br><span class="line"><span class="keyword">return</span> s.size</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Define <code>iShoe and shoe</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abstract_factory</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> shoe <span class="keyword">struct</span> {</span><br><span class="line">logo <span class="keyword">string</span></span><br><span class="line">size <span class="keyword">int</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> iShoe <span class="keyword">interface</span> {</span><br><span class="line">Size() <span class="keyword">int</span></span><br><span class="line">SetSize(size <span class="keyword">int</span>)</span><br><span class="line">Logo() <span class="keyword">string</span></span><br><span class="line">SetLogo(logo <span class="keyword">string</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *shoe)</span> <span class="title">SetLogo</span><span class="params">(logo <span class="keyword">string</span>)</span></span> {</span><br><span class="line">s.logo = logo</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *shoe)</span> <span class="title">Logo</span><span class="params">()</span> <span class="title">string</span></span> {</span><br><span class="line"><span class="keyword">return</span> s.logo</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *shoe)</span> <span class="title">SetSize</span><span class="params">(size <span class="keyword">int</span>)</span></span> {</span><br><span class="line">s.size = size</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *shoe)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">int</span></span> {</span><br><span class="line"><span class="keyword">return</span> s.size</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Define concrete<code>nike</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abstract_factory</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> nike <span class="keyword">struct</span>{}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> nikeShirt <span class="keyword">struct</span> {</span><br><span class="line">shirt</span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> nikeShoe <span class="keyword">struct</span> {</span><br><span class="line">shoe</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *nike)</span> <span class="title">Shoe</span><span class="params">()</span> <span class="title">iShoe</span></span> {</span><br><span class="line"><span class="keyword">return</span> &amp;nikeShoe{shoe: shoe{logo: <span class="string">"Nike"</span>, size: <span class="number">10</span>}}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *nike)</span> <span class="title">Shirt</span><span class="params">()</span> <span class="title">iShirt</span></span> {</span><br><span class="line"><span class="keyword">return</span> &amp;nikeShirt{shirt: shirt{logo: <span class="string">"Nike"</span>, size: <span class="number">20</span>}}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Define concrete<code>adidas</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abstract_factory</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> adidasShirt <span class="keyword">struct</span> {</span><br><span class="line">shirt</span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> adidasShoe <span class="keyword">struct</span> {</span><br><span class="line">shoe</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> adidas <span class="keyword">struct</span>{}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *adidas)</span> <span class="title">Shoe</span><span class="params">()</span> <span class="title">iShoe</span></span> {</span><br><span class="line"><span class="keyword">return</span> &amp;adidasShoe{shoe: shoe{logo: <span class="string">"Adidas"</span>, size: <span class="number">14</span>}}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *adidas)</span> <span class="title">Shirt</span><span class="params">()</span> <span class="title">iShirt</span></span> {</span><br><span class="line"><span class="keyword">return</span> &amp;adidasShirt{shirt: shirt{logo: <span class="string">"Adidas"</span>, size: <span class="number">30</span>}}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Define <code>iWearFactory</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abstract_factory</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> iWearFactory <span class="keyword">interface</span> {</span><br><span class="line">Shoe() iShoe</span><br><span class="line">Shirt() iShirt</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Brands <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">Nike Brands = <span class="literal">iota</span></span><br><span class="line">Adidas</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWearFactory</span><span class="params">(brand Brands)</span> <span class="title">iWearFactory</span></span> {</span><br><span class="line"><span class="keyword">switch</span> brand {</span><br><span class="line"><span class="keyword">case</span> Nike:</span><br><span class="line"><span class="keyword">return</span> &amp;nike{}</span><br><span class="line"><span class="keyword">case</span> Adidas:</span><br><span class="line"><span class="keyword">return</span> &amp;adidas{}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Simple usage:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">adidasFactory := abstract_factory.NewWearFactory(abstract_factory.Adidas)</span><br><span class="line">nikeFactory := abstract_factory.NewWearFactory(abstract_factory.Nike)</span><br><span class="line"></span><br><span class="line">shoe1 := nikeFactory.Shoe()</span><br><span class="line">shirt1 := nikeFactory.Shirt()</span><br><span class="line">shoe2 := adidasFactory.Shoe()</span><br><span class="line">shirt2 := adidasFactory.Shirt()</span><br><span class="line">fmt.Printf(<span class="string">"%v \n"</span>, shoe1)</span><br><span class="line">fmt.Printf(<span class="string">"%v \n"</span>, shoe2)</span><br><span class="line">fmt.Printf(<span class="string">"%v \n"</span>, shirt1)</span><br><span class="line">fmt.Printf(<span class="string">"%v \n"</span>, shirt2)</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Design Patterns | Factory</title>
      <link href="2021/03/14/go-design-patterns-factory/"/>
      <url>2021/03/14/go-design-patterns-factory/</url>
      
        <content type="html"><![CDATA[<p><strong>Creational</strong> pattern - <strong>Factory</strong></p><p>Use cases:</p><ul><li>when you don’t know what exact types and dependencies your code should support </li><li>when you want to extend some properties of objects that you provide</li><li>when you want to save resources by providing existing objects </li></ul><p>Pros: </p><ul><li>avoid coupling of between creator and concrete type </li><li>ability to add new types without breaking old code </li><li>more control on code because there are one place where your objects are creating</li></ul><p>Example: </p><p>Define <code>Product</code> interface with single method <code>GetCost()</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Product <span class="keyword">interface</span> {</span><br><span class="line">GetCost() <span class="keyword">int</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>Define two concrete types of <code>Product</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Phone <span class="keyword">struct</span> {</span><br><span class="line">cost <span class="keyword">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPhone</span><span class="params">(cost <span class="keyword">int</span>)</span> *<span class="title">Phone</span></span> {</span><br><span class="line"><span class="keyword">return</span> &amp;Phone{cost}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Phone)</span> <span class="title">GetCost</span><span class="params">()</span> <span class="title">int</span></span> {</span><br><span class="line"><span class="keyword">return</span> p.cost</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CarbonEmissionCost = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Car <span class="keyword">struct</span> {</span><br><span class="line">cost <span class="keyword">int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCar</span><span class="params">(cost <span class="keyword">int</span>)</span> *<span class="title">Car</span></span> {</span><br><span class="line"><span class="keyword">return</span> &amp;Car{cost}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Car)</span> <span class="title">GetCost</span><span class="params">()</span> <span class="title">int</span></span> {</span><br><span class="line"><span class="keyword">return</span> CarbonEmissionCost + c.cost</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>Define factory that will create for us <code>Product</code> types:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ProductType <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">PhoneType ProductType = <span class="literal">iota</span></span><br><span class="line">CarType</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ProductFactory <span class="keyword">struct</span> {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ProductFactory)</span> <span class="title">NewProduct</span><span class="params">(p ProductType, cost <span class="keyword">int</span>)</span> <span class="title">Product</span></span> {</span><br><span class="line"><span class="keyword">switch</span> p {</span><br><span class="line"><span class="keyword">case</span> PhoneType:</span><br><span class="line"><span class="keyword">return</span> NewPhone(cost)</span><br><span class="line"><span class="keyword">case</span> CarType:</span><br><span class="line"><span class="keyword">return</span> NewCar(cost)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Example of usage:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">products := []factory.Product{factory.NewCar(<span class="number">2000</span>), factory.NewPhone(<span class="number">800</span>)}</span><br><span class="line">totalCost := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> products {</span><br><span class="line">totalCost += v.GetCost()</span><br><span class="line">}</span><br><span class="line">fmt.Printf(<span class="string">"Total cost: %v$ "</span>, totalCost)</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Dynamic Programming | Practise 3</title>
      <link href="2021/03/14/algo-dynamic-programming-lcs2/"/>
      <url>2021/03/14/algo-dynamic-programming-lcs2/</url>
      
        <content type="html"><![CDATA[<p>In this article we talk about <strong>dynamic programming.</strong></p><p>Lets look at next question: </p><p>Given two strings <code>str1</code> and <code>str2</code>, return the shortest string that has both <code>str1</code> and <code>str2</code> as subsequences. If multiple answers exist, you may return any of them.</p><p><em>(A string S is a subsequence of string T if deleting some number of characters from T (possibly 0, and the characters are chosen anywhere from T) results in the string S.)</em></p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: str1 &#x3D; &quot;abac&quot;, str2 &#x3D; &quot;cab&quot;</span><br><span class="line">Output: &quot;cabac&quot;</span><br><span class="line">Explanation: </span><br><span class="line">str1 &#x3D; &quot;abac&quot; is a subsequence of &quot;cabac&quot; because we can delete the first &quot;c&quot;.</span><br><span class="line">str2 &#x3D; &quot;cab&quot; is a subsequence of &quot;cabac&quot; because we can delete the last &quot;ac&quot;.</span><br><span class="line">The answer provided is the shortest such string that satisfies these properties.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li><code>1 &lt;= str1.length, str2.length &lt;= 1000</code></li><li><code>str1</code> and <code>str2</code> consist of lowercase English letters.</li></ol><p>The problem can be found <a href="https://leetcode.com/problems/shortest-common-supersequence/">here.</a> </p><p>Problem very tricky and need some investigation. One of solutions could be dynamic programming approach. </p><p>You can come up with next statement: longest common subsequence of this two strings will be added to final answer only once. And another left chars must be added by order in which they appear from two strings. So, algorithm will be next: </p><ol><li>Find longest common subsequence</li><li>Add indexes of chars in longest common subsequence to list</li><li>Traverse both strings simultaneously and added each chars from strings to final answer, if char is char from longest common subsequence, then add this char once </li></ol><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">shortestCommonSupersequence</span><span class="params">(String s1, String s2)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n1 = s1.length(), n2 = s2.length();</span><br><span class="line">        <span class="keyword">int</span> [][] cache = <span class="keyword">new</span> <span class="keyword">int</span> [n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; ++i) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n2; ++j) {</span><br><span class="line">                <span class="keyword">if</span> (s1.charAt(i - <span class="number">1</span>) == s2.charAt(j - <span class="number">1</span>)) {</span><br><span class="line">                    cache[i][j] = cache[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    cache[i][j] = Math.max(cache[i-<span class="number">1</span>][j], cache[i][j-<span class="number">1</span>]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">int</span> r = n1, c = n2;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; lcs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(r &gt;= <span class="number">1</span> &amp;&amp; c &gt;= <span class="number">1</span> &amp;&amp; cache[r][c] != <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">if</span> (r &gt; <span class="number">1</span> &amp;&amp; cache[r-<span class="number">1</span>][c] == cache[r][c]) r--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c &gt; <span class="number">1</span> &amp;&amp; cache[r][c-<span class="number">1</span>] == cache[r][c]) c--;</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                lcs.add(<span class="keyword">new</span> <span class="keyword">int</span> [] {r - <span class="number">1</span>, c - <span class="number">1</span>});</span><br><span class="line">                r--;</span><br><span class="line">                c--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        Collections.reverse(lcs);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>, n = lcs.size();</span><br><span class="line">        StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n1 &amp;&amp; j &lt; n2 &amp;&amp; k &lt; n) {</span><br><span class="line">            <span class="keyword">boolean</span> d1 = lcs.get(k)[<span class="number">0</span>] == i, d2 = lcs.get(k)[<span class="number">1</span>] == j;</span><br><span class="line">            <span class="keyword">if</span> (d1 &amp;&amp; d2)  {</span><br><span class="line">                ans.append(s1.charAt(i));</span><br><span class="line">                ++k;</span><br><span class="line">                ++i;</span><br><span class="line">                ++j;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (d1 &amp;&amp; !d2) {</span><br><span class="line">                ans.append(s2.charAt(j++));</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (!d1 &amp;&amp; d2) {</span><br><span class="line">                ans.append(s1.charAt(i++));</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                ans.append(s1.charAt(i++));</span><br><span class="line">                ans.append(s2.charAt(j++));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        ans.append(s1.substring(i));</span><br><span class="line">        ans.append(s2.substring(j));</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>Notes: </p><ol><li>Declare cache array of lonest common subsequence</li><li>From line 3 to 13 find the lenths of longest common subsequence</li><li>From line 15 to 25 find indexes of chars of longest common subsequence</li><li>From line 29 to 44 traverse strings and add chars from to answer following rules from step 3 in algorithm</li><li>On lines 45 and 46 add left chars</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Breadth First Search | Practise 2</title>
      <link href="2021/03/06/bfs-algo/"/>
      <url>2021/03/06/bfs-algo/</url>
      
        <content type="html"><![CDATA[<p>In this article we talk about <strong>Breadth-first search.</strong></p><p>The main difference between <strong>BFS</strong> and <strong>DFS</strong> is solving approach. BFS uses <code>Queue</code> to solve problem while DFS uses <code>Stack</code>.  BFS grows equally by processing closest points while DFS go deep as much as possible on each iteration. We can get that by using <code>Queue</code> and <code>Stack</code>. </p><p>Let’s look at problem: </p><p>You are given an <code>m x n</code> <code>grid</code> where each cell can have one of three values:</p><ul><li><code>0</code> representing an empty cell,</li><li><code>1</code> representing a fresh orange, or</li><li><code>2</code> representing a rotten orange.</li></ul><p>Every minute, any fresh orange that is <strong>4-directionally adjacent</strong> to a rotten orange becomes rotten.</p><p>Return <em>the minimum number of minutes that must elapse until no cell has a fresh orange</em>. If <em>this is impossible, return</em> <code>-1</code>.</p><p>Problem can be found <a href="https://leetcode.com/problems/rotting-oranges/">here.</a></p><p>To solve this problem we can use BFS:</p><ol><li>Create <code>Queue</code> that will hold rotten oranges. Add all rotten oranges to this queue </li><li>Iterate in cylce while queue is not empty and do next:<ol><li>Poll rotten orange from queue</li><li>Check sorrounding oranges for fresh one. If there is then rotten orange and add to queue</li></ol></li><li>Check if all fresh oranges become rotten </li></ol><p>Solution: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">orangesRotting</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>{</span><br><span class="line">        Queue&lt;Pair&lt;Integer, Integer&gt;&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> fresh = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) {</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>) {</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> Pair(i, j));</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) {</span><br><span class="line">                    ++fresh;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> [] dirs = <span class="keyword">new</span> <span class="keyword">int</span> [] {<span class="number">1</span>,<span class="number">0</span>, -<span class="number">1</span>,<span class="number">0</span>, <span class="number">0</span>,<span class="number">1</span>, <span class="number">0</span>,-<span class="number">1</span>};</span><br><span class="line">        <span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) {</span><br><span class="line">            <span class="keyword">int</span> s = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; s; ++k) {</span><br><span class="line">                Pair&lt;Integer, Integer&gt; p = queue.poll();</span><br><span class="line">                <span class="keyword">int</span> currRow = p.getKey(), currCol = p.getValue();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j+=<span class="number">2</span>) {</span><br><span class="line">                    <span class="keyword">int</span> r = currRow + dirs[j], c = currCol + dirs[j+<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r == m || c == n || </span><br><span class="line">                       grid[r][c] != <span class="number">1</span>) {</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    }</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> Pair(r, c));</span><br><span class="line">                    grid[r][c] = <span class="number">2</span>;</span><br><span class="line">                    --fresh;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            ++time;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (fresh == <span class="number">0</span>) <span class="keyword">return</span> Math.max(<span class="number">0</span>, time - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>Another example:</p><p>There is an <strong>undirected</strong> graph with <code>n</code> nodes, where each node is numbered between <code>0</code> and <code>n - 1</code>. You are given a 2D array <code>graph</code>, where <code>graph[u]</code> is an array of nodes that node <code>u</code> is adjacent to. More formally, for each <code>v</code> in <code>graph[u]</code>, there is an undirected edge between node <code>u</code> and node <code>v</code>. The graph has the following properties:</p><ul><li>There are no self-edges (<code>graph[u]</code> does not contain <code>u</code>).</li><li>There are no parallel edges (<code>graph[u]</code> does not contain duplicate values).</li><li>If <code>v</code> is in <code>graph[u]</code>, then <code>u</code> is in <code>graph[v]</code> (the graph is undirected).</li><li>The graph may not be connected, meaning there may be two nodes <code>u</code> and <code>v</code> such that there is no path between them.</li></ul><p>A graph is <strong>bipartite</strong> if the nodes can be partitioned into two independent sets <code>A</code> and <code>B</code> such that <strong>every</strong> edge in the graph connects a node in set <code>A</code> and a node in set <code>B</code>.</p><p>Return <code>true</code> <em>if and only if it is <strong>bipartite</strong></em>.</p><p>Problem can be found <a href="https://leetcode.com/problems/is-graph-bipartite/">here.</a></p><p><em>Algorithms will be next</em>:</p><ol><li>Create integer colors array(<code>0 = not colored vertex, 1 - first group vertex, -1 - second group vertex</code>)</li><li>Iterate through graph:<ol><li>If vertex was colored, it means we have already checked all its’ adjacent vertices, just <code>continue</code> iteration</li><li>Color vertex and create a queue</li><li>Add vertex to queue and start cycle while queue is not empty <ol><li>Poll vertex from queue and check all its’ adjacent vertices <ol><li>If adjacent vertex is colored with same color then it’s not bipartite graph</li><li>If vertex is not colored yet, color it with opposite color and add current vertex to queue</li></ol></li></ol></li></ol></li></ol><p><em>Why we need to iterate through all graph in second step?</em></p><blockquote><p> Graph could be not connected, that is why we need to check all its’ components</p></blockquote><p>Solution: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = graph.length;</span><br><span class="line">        <span class="keyword">int</span>[] colors = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">            <span class="keyword">if</span> (colors[i] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            queue.offer(i);</span><br><span class="line">            colors[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">                <span class="keyword">int</span> v = queue.poll();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> u : graph[v]) {</span><br><span class="line">                    <span class="keyword">if</span> (colors[u] == colors[v]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (colors[u] == <span class="number">0</span>) {</span><br><span class="line">                        colors[u] = -colors[v];</span><br><span class="line">                        queue.offer(u);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Design Patterns | Builder</title>
      <link href="2021/02/09/go-design-patterns-builder/"/>
      <url>2021/02/09/go-design-patterns-builder/</url>
      
        <content type="html"><![CDATA[<p><strong>Creational</strong> pattern - <strong>Builder</strong> </p><p>Use cases: </p><ul><li>technique that allows to encapsulate construction logic for an object while creating  </li><li>break up construction of complex object into smaller parts and decople construction from its representation that can be reused to create different representations </li></ul><p>Let’s look at the example:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"encoding/xml"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MessageFormat <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">JSON_FORMAT MessageFormat = <span class="literal">iota</span></span><br><span class="line">XML_FORMAT</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> {</span><br><span class="line">Body   []<span class="keyword">byte</span></span><br><span class="line">Format MessageFormat</span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> MessageBuilder <span class="keyword">interface</span> {</span><br><span class="line">SetRecepient(recepient <span class="keyword">string</span>)</span><br><span class="line">SetText(text <span class="keyword">string</span>)</span><br><span class="line">Build() (*Message, error)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> JsonBuilder <span class="keyword">struct</span> {</span><br><span class="line">recepient <span class="keyword">string</span></span><br><span class="line">text      <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(jb *JsonBuilder)</span> <span class="title">SetRecepient</span><span class="params">(recepient <span class="keyword">string</span>)</span></span> {</span><br><span class="line">jb.recepient = recepient</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(jb *JsonBuilder)</span> <span class="title">SetText</span><span class="params">(text <span class="keyword">string</span>)</span></span> {</span><br><span class="line">jb.text = text</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(jb *JsonBuilder)</span> <span class="title">Build</span><span class="params">()</span> <span class="params">(*Message, error)</span></span> {</span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">m[<span class="string">"recepient"</span>] = jb.recepient</span><br><span class="line">m[<span class="string">"text"</span>] = jb.text</span><br><span class="line">data, err := json.Marshal(m)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> &amp;Message{Body: data, Format: JSON_FORMAT}, <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> XmlBuilder <span class="keyword">struct</span> {</span><br><span class="line">recepient <span class="keyword">string</span></span><br><span class="line">text      <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">type</span> XMLMessage <span class="keyword">struct</span> {</span><br><span class="line">Recipient <span class="keyword">string</span> <span class="string">`xml:"recipient"`</span></span><br><span class="line">Text      <span class="keyword">string</span> <span class="string">`xml:"body"`</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(xb *XmlBuilder)</span> <span class="title">SetRecepient</span><span class="params">(recepient <span class="keyword">string</span>)</span></span> {</span><br><span class="line">xb.recepient = recepient</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(xb *XmlBuilder)</span> <span class="title">SetText</span><span class="params">(text <span class="keyword">string</span>)</span></span> {</span><br><span class="line">xb.text = text</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(xb *XmlBuilder)</span> <span class="title">Build</span><span class="params">()</span> <span class="params">(*Message, error)</span></span> {</span><br><span class="line">m := XMLMessage{Recipient: xb.recepient, Text: xb.text}</span><br><span class="line">data, err := xml.Marshal(m)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> &amp;Message{Body: data, Format: XML_FORMAT}, <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Sender <span class="keyword">struct</span> {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Sender)</span> <span class="title">BuildMessage</span><span class="params">(mb MessageBuilder)</span> <span class="params">(*Message, error)</span></span> {</span><br><span class="line">mb.SetRecepient(<span class="string">"Santa Claus"</span>)</span><br><span class="line">mb.SetText(<span class="string">"I was a good body, give me a gift!"</span>)</span><br><span class="line"><span class="keyword">return</span> mb.Build()</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>The main idea is next: </p><ul><li><code>MessageFormat</code> defines two formats of message(xml, json)</li><li><code>Message</code> type  define two fields(body of message and format)</li><li><code>MessageBuilder</code> common interface for builder object with corresponding methods for setters and <code>Build()</code> function</li><li><code>JsonBuilder</code> and <code>XmlBuilder</code> are concrete implementations <code>MessageBuilder</code> interface. It creates messages in two different formats </li><li><code>Sender</code> is <em>director</em> class that creates message. It accepts a <code>MessageBuilder</code> type and build it. And it doesn’t really matter what exactly type of <code>MessageBuilder</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">sender := Sender{}</span><br><span class="line">jsonMsg, err := sender.BuildMessage(&amp;JsonBuilder{})</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">}</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(jsonMsg.Body))</span><br><span class="line">xmlMsg, err := sender.BuildMessage(&amp;XmlBuilder{})</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">}</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(xmlMsg.Body))</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Basic usage. Define director class and pass two different builders of <code>MessageBuilder</code> type. </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go run .</span><br><span class="line">{<span class="string">"recepient"</span>:<span class="string">"Santa Claus"</span>,<span class="string">"text"</span>:<span class="string">"I was a good body, give me a gift!"</span>}</span><br><span class="line">&lt;XMLMessage&gt;&lt;recipient&gt;Santa Claus&lt;/recipient&gt;&lt;body&gt;I was a good body, give me a gift!&lt;/body&gt;&lt;/XMLMessage&gt;</span><br></pre></td></tr></table></figure><p>Sample output.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Design Patterns | Prototype</title>
      <link href="2021/02/08/go-design-patterns-prototype/"/>
      <url>2021/02/08/go-design-patterns-prototype/</url>
      
        <content type="html"><![CDATA[<p><strong>Creational</strong> pattern - <strong>Prototype</strong></p><p>Use cases: </p><ul><li>you need  a chance to have a copy of given object without coupling on object’s dependency classes </li><li>your code shouldn’t depend on conrete realization of class </li><li>when you add some specific configuration to classes and want to supply your object with this config </li></ul><p>Example: </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> inode <span class="keyword">interface</span> {</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">string</span>)</span><br><span class="line">clone() inode</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Here we define basic interface inode that have clone and print functions.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> file <span class="keyword">struct</span> {</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *file)</span> <span class="title">print</span><span class="params">(identation <span class="keyword">string</span>)</span></span> {</span><br><span class="line">fmt.Printf(<span class="string">"%s printing file %s \n"</span>, identation, f.name)</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *file)</span> <span class="title">clone</span><span class="params">()</span> <span class="title">inode</span></span> {</span><br><span class="line"><span class="keyword">return</span> &amp;file{name: f.name}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Structure <code>file</code>code that <em>implements</em> inode interface.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> folder <span class="keyword">struct</span> {</span><br><span class="line">childrens []inode</span><br><span class="line">name      <span class="keyword">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *folder)</span> <span class="title">print</span><span class="params">(identation <span class="keyword">string</span>)</span></span> {</span><br><span class="line">fmt.Printf(<span class="string">"%s printing hierachy for folder %s \n"</span>, identation, f.name)</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> f.childrens {</span><br><span class="line">v.<span class="built_in">print</span>(identation + identation)</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *folder)</span> <span class="title">clone</span><span class="params">()</span> <span class="title">inode</span></span> {</span><br><span class="line">dir := &amp;folder{name: f.name}</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> f.childrens {</span><br><span class="line">dir.childrens = <span class="built_in">append</span>(dir.childrens, v.clone())</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> dir</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Structure <code>folder</code>code that <em>implements</em> inode interface.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">folder1 := initFS()</span><br><span class="line">folder2 := someBusinessLogic(folder1)</span><br><span class="line">folder1.<span class="built_in">print</span>(<span class="string">" "</span>)</span><br><span class="line">folder2.<span class="built_in">print</span>(<span class="string">" "</span>)</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someBusinessLogic</span><span class="params">(in inode)</span> <span class="title">inode</span></span> {</span><br><span class="line"><span class="keyword">return</span> in.clone()</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initFS</span><span class="params">()</span> <span class="title">inode</span></span> {</span><br><span class="line">file1 := &amp;file{name: <span class="string">"File1"</span>}</span><br><span class="line">file2 := &amp;file{name: <span class="string">"File2"</span>}</span><br><span class="line">file3 := &amp;file{name: <span class="string">"File3"</span>}</span><br><span class="line">folder1 := &amp;folder{</span><br><span class="line">childrens: []inode{file1},</span><br><span class="line">name:      <span class="string">"Folder1"</span>,</span><br><span class="line">}</span><br><span class="line">folder2 := &amp;folder{</span><br><span class="line">childrens: []inode{folder1, file2, file3},</span><br><span class="line">name:      <span class="string">"Folder2"</span>,</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> folder2</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Initialize filesystem and create identical copy.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">go run .</span><br><span class="line">printing hierachy <span class="keyword">for</span> folder Folder2</span><br><span class="line"> printing hierachy <span class="keyword">for</span> folder Folder1</span><br><span class="line">   printing file File1</span><br><span class="line"> printing file File2</span><br><span class="line"> printing file File3</span><br><span class="line">printing hierachy <span class="keyword">for</span> folder Folder2</span><br><span class="line"> printing hierachy <span class="keyword">for</span> folder Folder1</span><br><span class="line">   printing file File1</span><br><span class="line"> printing file File2</span><br><span class="line"> printing file File3</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Design Patterns | Singleton</title>
      <link href="2021/02/07/go-design-patterns-singleton/"/>
      <url>2021/02/07/go-design-patterns-singleton/</url>
      
        <content type="html"><![CDATA[<p><strong>Creational</strong> pattern - <strong>Singleton</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cards</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> holder <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> storeObject holder</span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> <span class="title">holder</span></span> {</span><br><span class="line">once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">storeObject = <span class="built_in">make</span>(holder)</span><br><span class="line">})</span><br><span class="line"><span class="keyword">return</span> storeObject</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Here we define package cards, that encapsulates relationship between card number and and owner of a card. It’s concurency free function <code>func New() </code>code, that creates object only if it’s not initialized before. </p><p>Below you can find the basic usage of this pattern:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"cards"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">store := cards.New()</span><br><span class="line">store[<span class="string">"1111-2222-3333-4444"</span>] = <span class="string">"John Doe"</span></span><br><span class="line">store2 := cards.New()</span><br><span class="line">fmt.Println(store2[<span class="string">"1111-2222-3333-4444"</span>])</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Sample output of program shows that there are no another instance was created. </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Data Structures | AVL</title>
      <link href="2021/02/06/AVL/"/>
      <url>2021/02/06/AVL/</url>
      
        <content type="html"><![CDATA[<p>​    In this article we talk about <strong>AVL</strong> tree.</p><p>​    AVL is self-balanced tree, where for each node difference between height of left and right subtrees no more than 1. </p><p>​    Whenever you insert a node into tree, you always rebalance tree. Asymptotic complexity of  insert, search, and delete operations - logarithmic complexity and linear complexity for space complexity. Let’s define <strong>balance</strong> property of node. Balance property equals difference of height of left and right subtrees. If <code>|difference| &lt;= 1</code>, then the node is said balanced, otherwise not balanced.</p><p>​    Whenever we peform insert operation, we need always check on balance property(of new value’s ancestor). If if not balanced, then rebalance tree by rotating operation.</p><p>There are 4 rotations exists:</p><ul><li>Left rotation</li><li>Right rotation</li><li>Left-Right rotation</li><li>Right-Left rotation</li></ul><p>The last two is compositions of first two(with different orders).</p><p>Example of implementation of insert operation: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> play;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AVL</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(Node node)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> node.height;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">balance</span><span class="params">(Node node)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> height(node.left) - height(node.right);</span><br><span class="line">    } </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">leftRotate</span><span class="params">(Node node)</span> </span>{</span><br><span class="line">        Node retNode = node.right;</span><br><span class="line">        Node leftNode = retNode.left;</span><br><span class="line">        retNode.left = node;</span><br><span class="line">        node.right = leftNode;</span><br><span class="line">        <span class="keyword">return</span> retNode;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">rightRotate</span><span class="params">(Node node)</span> </span>{</span><br><span class="line">        Node retNode = node.left;</span><br><span class="line">        Node rightNode = retNode.right;</span><br><span class="line">        retNode.right = node;</span><br><span class="line">        node.left = rightNode;</span><br><span class="line">        <span class="keyword">return</span> retNode;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        root = insertRecursively(root, val);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">insertRecursively</span><span class="params">(Node node, <span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> Node(val);</span><br><span class="line">        <span class="keyword">if</span> (node.val &lt; val) {</span><br><span class="line">            node.right = insertRecursively(node.right, val);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (node.val &gt; val) {</span><br><span class="line">            node.left = insertRecursively(node.left, val);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        }</span><br><span class="line">        node.height = <span class="number">1</span> + Math.max(height(node.left), height(node.right));</span><br><span class="line">        <span class="keyword">int</span> bal = balance(node);</span><br><span class="line">        <span class="keyword">if</span> (bal &gt; <span class="number">1</span> &amp;&amp; val &lt; node.left.val) {</span><br><span class="line">            <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (bal &lt; -<span class="number">1</span> &amp;&amp; val &gt; node.right.val) {</span><br><span class="line">            <span class="keyword">return</span> leftRotate(node);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (bal &gt; <span class="number">1</span> &amp;&amp; val &gt; node.left.val) {</span><br><span class="line">            node.left = leftRotate(node.left);</span><br><span class="line">            <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (bal &lt; - <span class="number">1</span> &amp;&amp; val &lt; node.right.val) {</span><br><span class="line">            node.right = rightRotate(node.right);</span><br><span class="line">            <span class="keyword">return</span> leftRotate(node);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">()</span> </span>{</span><br><span class="line">        inorderRecursively(root);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorderRecursively</span><span class="params">(Node node)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inorderRecursively(node.left);</span><br><span class="line">        System.out.println(node.val);</span><br><span class="line">        inorderRecursively(node.right);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Data Structures | Binary Search Tree</title>
      <link href="2021/02/05/bst/"/>
      <url>2021/02/05/bst/</url>
      
        <content type="html"><![CDATA[<p>In this article we will talk about <strong>Binary Search Tree.</strong></p><p><em>What is the binary search tree?</em></p><p>Node based data structure with following properties:</p><ul><li>The left subtree of node contains values that are lesser than node’s value</li><li>The right subtree of node contains values that are bigger than nodes’ value</li><li>Left and right subtrees are also binary search trees.</li></ul><p><em>Which operations we can peform on binary search trees?</em></p><ul><li>Insert value</li><li>Get minimum value</li><li>Get maximum value</li><li>Search value</li><li>Get height of tree</li><li>Delete value</li></ul><p><em>Are they contains duplicates?</em></p><p>No</p><p><em>What about asymptotic complexity of operations?</em> </p><p>Depends on “balance” property. In balanced trees - logarithmic complexity, in unbalanced trees - linear complexity. </p><p><em>What about space complexity?</em> </p><p>Linear complexity</p><p><em>What about insert operation?</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> Node root;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">            root = <span class="keyword">new</span> Node(val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        } </span><br><span class="line">        insertRecursively(root, val); </span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">insertRecursively</span><span class="params">(Node node, <span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) {</span><br><span class="line">            node = <span class="keyword">new</span> Node(val);</span><br><span class="line">            <span class="keyword">return</span> node;   </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (val &gt; node.val) node.right = insertRecursively(node.right, val);</span><br><span class="line">        <span class="keyword">if</span> (val &lt; node.val) node.left = insertRecursively(node.left, val);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>If tree is empty then define root with value val, otherwise insert recursively into tree, until we find suitable place.<code>insertRecursively</code> function search for suitable place, if there is some insert new node and return newely created node, otherwise search suitable place in children’s subtrees and return given current node.</p><p><em>What about get maximum, minimum value operation?</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaximum</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> getMaximumRecursively(root);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMaximumRecursively</span><span class="params">(Node node)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) <span class="keyword">return</span> getMaximumRecursively(node.right);</span><br><span class="line">    <span class="keyword">return</span> node.val;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>As we know each node’s right children is bigger than current node, so the most biggest node is rightmost.</p><p>The same logic for minumum operation: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimum</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> getMinimumRecursively(root);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMinimumRecursively</span><span class="params">(Node node)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) <span class="keyword">return</span> getMinimumRecursively(node.left);</span><br><span class="line">    <span class="keyword">return</span> node.val;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><em>What about search operation?</em> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> searchRecursively(root, val);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchRecursively</span><span class="params">(Node node, <span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (val &gt; node.val) <span class="keyword">return</span> searchRecursively(node.right, val);</span><br><span class="line">    <span class="keyword">if</span> (val &lt; node.val) <span class="keyword">return</span> searchRecursively(node.left, val);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><em>What about height operation?</em> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> getHeightRecursively(root);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeightRecursively</span><span class="params">(Node node)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Math.max(getHeightRecursively(node.left), getHeightRecursively(node.right));</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><em>What about delete operation?</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteValue</span><span class="params">(<span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">    deleteRecursively(root, val);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">deleteRecursively</span><span class="params">(Node node, <span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> node;</span><br><span class="line">    <span class="keyword">if</span> (val &gt; node.val) {</span><br><span class="line">        node.right = deleteRecursively(node.right, val);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; node.val) {</span><br><span class="line">        node.left = deleteRecursively(node.left, val);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) <span class="keyword">return</span> node.left;</span><br><span class="line">        <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) <span class="keyword">return</span> node.right;</span><br><span class="line">        <span class="keyword">int</span> minNodeOnRightSubtreeValue = getMinimumRecursively(node.right);</span><br><span class="line">        node.val = minNodeOnRightSubtreeValue;</span><br><span class="line">        node.right = deleteRecursively(node.right, minNodeOnRightSubtreeValue);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>If node do not present in tree, so nothings happens. </p><p>If deleting node has one child then return that child(change refference of node’s parent child to node’s child)</p><p>If deleting node has two childrens then find the smallest value in right subtree, setup that value to current node’s value and recursively delete smallest node. </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Algorithms | Traverse Binary Tree</title>
      <link href="2021/02/04/traverse-tree/"/>
      <url>2021/02/04/traverse-tree/</url>
      
        <content type="html"><![CDATA[<p>In this article we will talk about <strong>Traverse Binary Tree.</strong></p><p>Here is an example of traversing trees with inorder, preorder, postorder </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line">    Node(<span class="keyword">int</span> val) {</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Node node)</span> </span>{</span><br><span class="line">    System.out.format(<span class="string">"%s -&gt;"</span>, node.val);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(Node node)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    inorder(node.left);</span><br><span class="line">    visit(node);</span><br><span class="line">    inorder(node.right);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(Node node)</span> </span>{</span><br><span class="line">    visit(node);</span><br><span class="line">    preorder(node.left);</span><br><span class="line">    preorder(node.right);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">(Node node)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    preorder(node.left);</span><br><span class="line">    preorder(node.right);</span><br><span class="line">    visit(node);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>Moreover you can BFS and DFS on trees.</p><p>BFS:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Node root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) {</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; ++j) {</span><br><span class="line">            Node node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) queue.offer(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) queue.offer(node.right);</span><br><span class="line">            visit(node);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>DFS: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty()) {</span><br><span class="line">        Node node = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) stack.push(node.right);</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) stack.push(node.left);</span><br><span class="line">        visit(node);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Isolation levels</title>
      <link href="2021/02/03/isolation-levels/"/>
      <url>2021/02/03/isolation-levels/</url>
      
        <content type="html"><![CDATA[<p>In this article we will talk about <strong>isolation levels</strong> in RDBMS.</p><p>​    If multiple transactions do not process the same data, they can run safely in parallel. Race conditions becomes inevitable when one transaction process data that was modified by another transaction. </p><p>​    That is why it’s important to deal properly in this situation. The strongest level of consistency that could provide database - <strong>serializable isolation level.</strong> It’s like sequential running transactions if they share common data in database. How we can achieve that level? Just simply put locks on data that we have read or write during transcation. And no one else can access data while we unlock that data. It means no one can access data and there are a wait look on it. After data was unlocked another transcation cat start process interesting data. If we use such approach for every transcations that we run in database, we get big performance issue. And for this purposes there are exists another “weak” levels of isolations that could give guarantess with conditions to process transactions correctly. </p><p><strong>Read commited</strong></p><p>​    The default level in many databases that gives you two guarantees. Transaction reads only committed data. It’s impossible to read data that wasn’t committed. For example in case when you some transaction starts modifying data and at some moment of time get aborted. There is no middle time transaction that was read uncommitted data that was never existed. Another synonym for this is <strong>no dirty reads</strong>. The same works for writes. You never write data that wasn’t committed, <strong>no drity writes.</strong> Implementing no dirty writes like putting lock on data before modyfing data. It must wait until lock asquired before modifying data. Most databases stores old and new value of data to prevent dirty writes. </p><p><strong>Repeatable read</strong></p><p>​    Suppose you two have account in bank with 500$ on each. And you wanna get total sum of your money. You read first accont and get 500$. At this point of time another transactions start transfer 100$ from one account to another. Transaction increments first account by 100$ and decrements by 100$ on second account and committed succefully. You continue reading second account money and get 400$ in it. So totally you get 900$, but in fact it must be 1000$. This phenomenon names non repeatable read. And Repeatable read isolation level guarantees to you to escape <strong>non repeatable read</strong>. To implement this behaviour you need to keep snapshot isolation in your database, that also relates to storing different versions of your data(MVCC) while transactions are running under this level. Every transaction has it’s own auto incrementing id. And transactions can differentiate data by applying knowledge from this ids. </p><p>​    Both levels don’t prevent from <strong>lost update,</strong> that happens when you need read value, modify it and save back. If two transcation do this concurently you will probably lose one of the modification, because some transaction don’t consider first modification and rewrite value. For this problem there are several solutions: </p><p><strong>Atomic write</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> counters <span class="keyword">SET</span> <span class="keyword">value</span> <span class="operator">=</span> <span class="keyword">value</span> <span class="operator">+</span> <span class="number">1</span> <span class="keyword">WHERE</span> key <span class="operator">=</span> <span class="string">&#x27;foo&#x27;</span>;</span><br></pre></td></tr></table></figure><p>In given query, database setup exclusive lock on value, so that no one can access value while “incrementation” happens. </p><p>Another way to use <strong>explicit lock:</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACTION;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> figures</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;robot&#x27;</span> <span class="keyword">AND</span> game_id <span class="operator">=</span> <span class="number">222</span></span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="comment">-- Check whether move is valid, then update the position</span></span><br><span class="line"><span class="comment">-- of the piece that was returned by the previous SELECT.</span></span><br><span class="line"><span class="keyword">UPDATE</span> figures <span class="keyword">SET</span> position <span class="operator">=</span> <span class="string">&#x27;c4&#x27;</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1234</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>The key for lock is <code>FOR UPDATE</code> statement, that locks desired rows. Other transactions considering that consider locked rows waits until lock is released. </p><p><strong>Automatically detecting lost update</strong> is one of the the way to deal situation. In this case database automatically find losted updates and abort transaction or give another try again. </p><p>If you don’t use transactions it’s possible to prevent lost update by doing <strong>compare and set:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> wiki_pages <span class="keyword">SET</span> content <span class="operator">=</span> <span class="string">&#x27;new content&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1234</span> <span class="keyword">AND</span> content <span class="operator">=</span> <span class="string">&#x27;old content&#x27;</span>;</span><br></pre></td></tr></table></figure><p>Keep in mind to handle situation when you need to try again if no updates happened. </p><p><strong>Phantoms</strong> phenomena can’t also be preveneted by applying given isolation levels. Phantoms happens when you consider data that can’t be attached to some lock in database, for example while registering in service, you select accounts with given username and if there is no accounts you create account and concurrent transaction could also successfully repeat actions. </p><p><strong>Serializable isolation</strong></p><p>The strongest form of guarantee. There are 3 ways to implement this:</p><ol><li>Serial processing of transactions </li><li>Two phase locking </li><li>Optimistic concurrency control </li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ACID</title>
      <link href="2021/02/02/acid/"/>
      <url>2021/02/02/acid/</url>
      
        <content type="html"><![CDATA[<p>The safety guarantees provided by transactions are often know as acronym <strong>ACID</strong>, that stands for <strong>Atomacity, Consistency, Isolation and Durabilty</strong>. It’s important to differentiate from <strong>BASE</strong> acronym which stands for Basically Available Soft State, Eventual consistency. ACID relates to transactions, while BASE it’s more about system. Let’s describe each letter sequentially.</p><p><strong>Atomacity</strong></p><p>​    Imagine situation where you wanna send a multiple write queries to database and unfortunately something bad happened between query processing. Process crashes or network interrrupt or someone unplug electrical cable. How you fix this situation? Send write queries again? This thing can happen everywhere and every time, that is why transcations provide such a good thing atomaticy. Something that you can’t break into smaller parts and processed by database like a one query. By this property possible solution would be to abord all writes within this transaction. And if run your database after crash transation would be reject as not completed. This works by transcation journal.  </p><p><strong>Consistency</strong></p><p>​    Atomacity, durability, isolation - properties of database, while consistency - property of application. It’s up to you to decided wether you application in consistent way or not. And you can relate to ACID properties as an ultimate truth to stay your data consistent. </p><p><strong>Isolation</strong></p><p>​    Databases are concurrent. It’s often happens when transactions processes concurently and if some transcation will see middle results of another transaction that could be aborted or commited we can get wrong results by condsidering not commited results. And for this case isolation make possible to run transaction like a single transcation in database at current time. It’s like sequential running of transactions, while databases uses MVCC to bring isolation between transactions. </p><p><strong>Durability</strong></p><p>​    This property ensures that once transcation was completed the data will be completely saved even if system crash happens. For single node database it would be a promise to write data for non volatile storage, in replicated database it could mean that the data was completely copied to all nodes. </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Dynamic Programming | LCS | Practise 1</title>
      <link href="2021/02/01/lcs-dynamic/"/>
      <url>2021/02/01/lcs-dynamic/</url>
      
        <content type="html"><![CDATA[<p>In this article we will talk about Longest Common Sunsequence.<br>Given next problem:<br><em>Given two words word1 and word2, find the minimum number of steps required to make word1 and word2 the same, where in each step you can delete one character in either string.</em></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example</span><br><span class="line">Input: &quot;sea&quot;, &quot;eat&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: You need one step to make &quot;sea&quot; to &quot;ea&quot; and another step to make &quot;eat&quot; to &quot;ea&quot;.</span><br></pre></td></tr></table></figure><p>Intuitively we get recursive solution. Lets define next function:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcs</span><span class="params">(String s1, String s2, <span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span> </span></span><br></pre></td></tr></table></figure><p>Function returns the common longest subsequence for strings s1 and s2 with corresponding length n1 and n2.</p><ol><li>Base case would be when n1 or n2 equals to zero, in this case longest common subsequence of empty and not empty strings would be empty string. Return value would be <code>0</code>.</li><li>There are two cases exists:<ol><li><code>s1.charAt(n1 - 1) == s2.charAt(n2 - 1).</code> In this case we know that given strings of size n1 and n2 has two same chars at positions n1 - 1 and n2 - 1. And all we need to do is to find common subseqence of strings n1 - 1, n2 - 1. Return value would be <code>1 + lcs(s1, s2, n1 - 1, n2 - 1)</code></li><li><code>s1.charAt(n1 - 1) != s2.charAt(n2 - 1).</code>In this case we can conlcude that common subsequence could end at index n1 - 1 or n2 - 1. That is why we need to check both cases and select maximum common subsequence. Return value would be <code> Math.min(lcs(s1,s2,n1,n2-1), lcs(s2,s2,n1-1,n2);</code></li></ol></li></ol><p>Lets combine this into one function:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lcs</span><span class="params">(String s1, String s2, <span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n1 == <span class="number">0</span> || n2 == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (s1.charAt(n1-<span class="number">1</span>) == s2.charAt(n2-<span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + lcs(s1,s2, n1-<span class="number">1</span>, n2-<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(lcs(s1,s2,n1-<span class="number">1</span>,n2),lcs(s1,s2,n1,n2-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Keep in mind: we need substract double length of lcs from sum of length of strings. Because the statement is to find minimum number of chars to delete to get equal strings. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;sea&quot;</span>, s2 = <span class="string">&quot;eat&quot;</span>;</span><br><span class="line">        System.out.format(<span class="string">&quot;Ans is %d&quot;</span>, minDelete(s1,s2));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minDelete</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = s1.length(), n2 = s2.length();</span><br><span class="line">        <span class="keyword">return</span> n1 + n2 - <span class="number">2</span> * lcs(s1,s2,n1,n2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lcs</span><span class="params">(String s1, String s2, <span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n1 == <span class="number">0</span> || n2 == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (s1.charAt(n1-<span class="number">1</span>) == s2.charAt(n2-<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + lcs(s1,s2, n1-<span class="number">1</span>, n2-<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(lcs(s1,s2,n1-<span class="number">1</span>,n2),lcs(s1,s2,n1,n2-<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Let’s optimize algorithm. Recursion calls itself again and again, and instead of getting values from recursion we can cache answers and use it later. Cache would be simple two dimensional array of size n1 + 1, n2 + 1, that holds Integers. If <code>cache[i][j] != null</code> then cache holds precomputed value, otherwise compute and update cache.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minDelete</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n1 = s1.length(), n2 = s2.length();</span><br><span class="line">    Integer[][] cache = <span class="keyword">new</span> Integer[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> n1 + n2 - <span class="number">2</span> * lcs(cache, s1,s2,n1,n2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lcs</span><span class="params">(Integer [][] cache, String s1, String s2, <span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cache[n1][n2] != <span class="keyword">null</span>) <span class="keyword">return</span> cache[n1][n2];</span><br><span class="line">    <span class="keyword">if</span> (n1 == <span class="number">0</span> || n2 == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="keyword">if</span> (s1.charAt(n1-<span class="number">1</span>) == s2.charAt(n2-<span class="number">1</span>)) &#123;</span><br><span class="line">        ans = <span class="number">1</span> + lcs(cache, s1,s2, n1-<span class="number">1</span>, n2-<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ans = Math.max(lcs(cache, s1,s2,n1-<span class="number">1</span>,n2),lcs(cache, s1,s2,n1,n2-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache[n1][n2] = ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We can break algorithm if we provide big strings that gives overflow of stack. It has place to make iterative solution. The idea remains the same. If current chars <code>i, j</code> are same we have got new longest subsequence at path <code>cache[i][j]</code>, if not then the answer would be the biggest value between <code>cache[i][j-1]</code> and <code>cache[i-1][j]</code>(don’t forget to change <code>Integer[][]cache -&gt; int[][]cache</code>).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static int lcs(int [][] cache, String s1, String s2, int n1, int n2) &#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt;&#x3D; n1; ++i) &#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt;&#x3D; n2; ++j) &#123;</span><br><span class="line">            if (i &#x3D;&#x3D; 0 || j &#x3D;&#x3D; 0) continue;</span><br><span class="line">            if (s1.charAt(i - 1) &#x3D;&#x3D; s2.charAt(j - 1)) &#123;</span><br><span class="line">                cache[i][j] &#x3D; 1 + cache[i-1][j-1];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cache[i][j] &#x3D; Math.max(cache[i][j-1], cache[i-1][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return cache[n1][n2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Data Structures | Disjoint-Set(Union Find)</title>
      <link href="2021/01/31/union-find/"/>
      <url>2021/01/31/union-find/</url>
      
        <content type="html"><![CDATA[<p>In this article we will talk about <strong>Union Find.</strong></p><p>Let’s imagine that we have set of N elements, and some elements are connected. Elements that are connected produce some subset. Your question is to find number of distinct subsets or to find set with maximum number of members.</p><p><strong>Case #1</strong><br><em>There are n cities and k connections. Connected cities(directly or indirectly) declares province. Find total number of province.</em></p><p>Constraints: </p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= n &lt;= 10000</span><br><span class="line">arr[s] = [i,j]; 1 &lt;= i,j &lt;= n, i != j, [i,j] - unique pairs</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Example #1 </span><br><span class="line">Input: </span><br><span class="line">10 </span><br><span class="line">[[1,2], [1,3], [2,5], [7,8], [5, 6], [9,10]]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p>From example above you can see that provinces are:</p><ul><li>1, 2, 3, 5, 6</li><li>4</li><li>7, 8 </li><li>9, 10</li></ul><p>In total we have 4 provinces. </p><p>Efficient approach to solve this problem is to use Union Find DS. The main idea is</p><ol><li><p>Create unique ids array for each element in set. It means if we have 10 elements in set, unique ids are nums[1,2,3,4,5,6,7,8,9,10]. </p></li><li><p>Define root element. Root element is an element where nums[i] = i. Initially all elements are roots. We have 10 roots. If we have nums = [1, 1, 1, 1, 5, 5, 5, 5, 9, 10], it means root elements are 1, 5, 9, 10, moreover if we have nums = [1, 1, 1, 1, 1, 1, 5, 5, 9, 10], then root elements are 1, 9, 10 (because nums[5] =1)</p></li><li><p>Implement “find” function. “Find” function searches root of element.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">while</span>(nums[i] != i) &#123;</span><br><span class="line">          i = nums[i];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Implement union function. Union function connect to elements. How do we do this? Find root of first element(root1), find root of second element(root2). Setup nums[root1] = root2</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> rootI = find(nums, i);</span><br><span class="line">       <span class="keyword">int</span> rootJ = find(nums, j);</span><br><span class="line">       nums[rootI] = rootJ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Let’s define final algorithm for the question:</p><ol><li>Create unique ids array(nums)</li><li>Iterate through connection array and union cities </li><li>Find total number of roots in nums. </li></ol><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> [][] connections = <span class="keyword">new</span> <span class="keyword">int</span> [][] &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;, &#123;<span class="number">1</span>,<span class="number">3</span>&#125;, &#123;<span class="number">2</span>,<span class="number">5</span>&#125;, &#123;<span class="number">7</span>,<span class="number">8</span>&#125;, &#123;<span class="number">5</span>,<span class="number">6</span>&#125;, &#123;<span class="number">9</span>,<span class="number">10</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> ans = numberOfProvince(n, connections);</span><br><span class="line">        System.out.format(<span class="string">&quot;Number of provinces - %d&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(nums[i] != i) &#123;</span><br><span class="line">            i = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootI = find(nums, i);</span><br><span class="line">        <span class="keyword">int</span> rootJ = find(nums, j);</span><br><span class="line">        nums[rootI] = rootJ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numberOfProvince</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] connections)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span> [n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            nums[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] conn: connections) &#123;</span><br><span class="line">            union(nums, conn[<span class="number">0</span>], conn[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; roots = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> currRoot = find(nums, i);</span><br><span class="line">            roots.add(currRoot);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> roots.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Case #2</strong></p><p><em>Given an unsorted array of integers arr, find the length of longest consucutive elements sequence.</em> </p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Example #1</span><br><span class="line">Input: nums = [100,4,200,1,3,2]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.</span><br><span class="line"></span><br><span class="line">Example #2</span><br><span class="line">Input: nums = [0,3,7,2,5,8,4,6,0,1]</span><br><span class="line">Output: 9</span><br></pre></td></tr></table></figure><p>If you think about this problem in Union Find way, you can get that all consecutive elements sequece define some subset(connected component) and all we need to do is to find the biggest one. In general we need to iterate through array and try to union elements (val, val + 1) and (val, val - 1) if they given. It means we need to know whether there exists values (val + 1) or (val - 1) in order to retrive their indexes. This can be done via projecting values to indexes. Map would be effecient way. What happens if you have duplicates? Actually it doesn’t matter, because we store only the last occurence of value in map and we need keep in mind to process indexes that are exists in map. How we can get maximum size set? We can create another array counter, that will keep track size of each root’s set.</p><p>Solution: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] arr = <span class="keyword">new</span> <span class="keyword">int</span> [] &#123;<span class="number">100</span>,<span class="number">4</span>,<span class="number">200</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> ans = longestConsecutive(arr);</span><br><span class="line">        System.out.format(<span class="string">&quot;Longest sequence size - %d&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(nums[i] != i) &#123;</span><br><span class="line">            i = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootI = find(nums, i);</span><br><span class="line">        <span class="keyword">int</span> rootJ = find(nums, j);</span><br><span class="line">        nums[rootI] = rootJ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> [] nums = <span class="keyword">new</span> <span class="keyword">int</span> [n];</span><br><span class="line">        Map&lt;Integer, Integer&gt; mp = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;++i) &#123;</span><br><span class="line">            nums[i] = i;</span><br><span class="line">            mp.put(arr[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mp.get(arr[i]) != i) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> prev = arr[i] - <span class="number">1</span>, next = arr[i] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (mp.containsKey(prev)) &#123;</span><br><span class="line">                union(nums, i, mp.get(prev));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mp.containsKey(next))  &#123;</span><br><span class="line">                union(nums, i, mp.get(next));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> [] counter = <span class="keyword">new</span> <span class="keyword">int</span> [n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> currRoot = find(nums, i);</span><br><span class="line">            ans = Math.max(ans, ++counter[currRoot]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Both problems can be found in leetcode.com.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Algorithms | Major Element In Array</title>
      <link href="2021/01/30/major-element/"/>
      <url>2021/01/30/major-element/</url>
      
        <content type="html"><![CDATA[<p>In this article we will talk about finding <strong>majority element</strong> in array. </p><p>Major element is an element that apeears in array more than half of array size times.</p><p>If you think about brute force solution, you can get this by doing O(n<sup>2</sup>) time complexity, meanwhile there are exists linear complexity solution named <strong>Moore’s Voting Algorithm.</strong></p><p>The basic idea is simple. Setup current major element as first element in array and created variable counter with value 1. Iterate through array and increment counter by one if current value in array equals to current major element, otherwise decrement counter. If counter equals to zero, then current element in array would be a new major element and setup counter to 1. </p><p>After end of loop count major element in array, if there are more than half of array size repetitions, that element is <strong>major element</strong>, otherwise there is no major element.</p><p>Algorithm:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] arr = <span class="keyword">new</span> <span class="keyword">int</span> [] &#123;<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">55</span>,<span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> ans = majorElement(arr);</span><br><span class="line">            System.out.format(<span class="string">&quot;Major element is %d&quot;</span>, ans);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception err) &#123;</span><br><span class="line">            System.err.println(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">majorElement</span><span class="params">(<span class="keyword">int</span>[] arr)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">int</span> ans = arr[<span class="number">0</span>], counter = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans == arr[i])</span><br><span class="line">                counter++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                counter--;</span><br><span class="line">            <span class="keyword">if</span> (counter == <span class="number">0</span>) &#123;</span><br><span class="line">                counter = <span class="number">1</span>;</span><br><span class="line">                ans = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == ans)</span><br><span class="line">                count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; n / <span class="number">2</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;No major element&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
