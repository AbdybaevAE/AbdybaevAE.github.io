<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Trees | Binary Search Tree</title>
      <link href="2021/02/06/bst/"/>
      <url>2021/02/06/bst/</url>
      
        <content type="html"><![CDATA[<p>In this article we will talk about <strong>Binary Search Tree.</strong></p><p><em>What is the binary search tree?</em></p><p>Node based data structure with following properties:</p><ul><li>The left subtree of node contains values that are lesser than node’s value</li><li>The right subtree of node contains values that are bigger than nodes’ value</li><li>Left and right subtrees are also binary search trees.</li></ul><p><em>Which operations we can peform on binary search trees?</em></p><ul><li>Insert value</li><li>Get minimum value</li><li>Get maximum value</li><li>Search value</li><li>Get height of tree</li><li>Delete value</li></ul><p><em>Are they contains duplicates?</em></p><p>No</p><p><em>What about asymptotic complexity of operations?</em> </p><p>Depends on “balance” property. In balanced trees - logarithmic complexity, in unbalanced trees - linear complexity. </p><p><em>What about space complexity?</em> </p><p>Linear complexity</p><p><em>What about insert operation?</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> Node root;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">            root = <span class="keyword">new</span> Node(val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        } </span><br><span class="line">        insertRecursively(root, val); </span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">insertRecursively</span><span class="params">(Node node, <span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) {</span><br><span class="line">            node = <span class="keyword">new</span> Node(val);</span><br><span class="line">            <span class="keyword">return</span> node;   </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (val &gt; node.val) node.right = insertRecursively(node.right, val);</span><br><span class="line">        <span class="keyword">if</span> (val &lt; node.val) node.left = insertRecursively(node.left, val);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>If tree is empty then define root with value val, otherwise insert recursively into tree, until we find suitable place.<code>insertRecursively</code> function search for suitable place, if there is some insert new node and return newely created node, otherwise search suitable place in children’s subtrees and return given current node.</p><p><em>What about get maximum, minimum value operation?</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaximum</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> getMaximumRecursively(root);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMaximumRecursively</span><span class="params">(Node node)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) <span class="keyword">return</span> getMaximumRecursively(node.right);</span><br><span class="line">    <span class="keyword">return</span> node.val;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>As we know each node’s right children is bigger than current node, so the most biggest node is rightmost.</p><p>The same logic for minumum operation: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimum</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> getMinimumRecursively(root);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMinimumRecursively</span><span class="params">(Node node)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) <span class="keyword">return</span> getMinimumRecursively(node.left);</span><br><span class="line">    <span class="keyword">return</span> node.val;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><em>What about search operation?</em> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> searchRecursively(root, val);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchRecursively</span><span class="params">(Node node, <span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (val &gt; node.val) <span class="keyword">return</span> searchRecursively(node.right, val);</span><br><span class="line">    <span class="keyword">if</span> (val &lt; node.val) <span class="keyword">return</span> searchRecursively(node.left, val);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><em>What about height operation?</em> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> getHeightRecursively(root);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeightRecursively</span><span class="params">(Node node)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Math.max(getHeightRecursively(node.left), getHeightRecursively(node.right));</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><em>What about delete operation?</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteValue</span><span class="params">(<span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">    deleteRecursively(root, val);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">deleteRecursively</span><span class="params">(Node node, <span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> node;</span><br><span class="line">    <span class="keyword">if</span> (val &gt; node.val) {</span><br><span class="line">        node.right = deleteRecursively(node.right, val);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; node.val) {</span><br><span class="line">        node.left = deleteRecursively(node.left, val);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) <span class="keyword">return</span> node.left;</span><br><span class="line">        <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) <span class="keyword">return</span> node.right;</span><br><span class="line">        <span class="keyword">int</span> minNodeOnRightSubtreeValue = getMinimumRecursively(node.right);</span><br><span class="line">        node.val = minNodeOnRightSubtreeValue;</span><br><span class="line">        node.right = deleteRecursively(node.right, minNodeOnRightSubtreeValue);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>If node do not present in tree, so nothings happens. </p><p>If deleting node has one child then return that child(change refference of node’s parent child to node’s child)</p><p>If deleting node has two childrens then find the smallest value in right subtree, setup that value to current node’s value and recursively delete smallest node. </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Isolation levels</title>
      <link href="2021/02/03/isolation-levels/"/>
      <url>2021/02/03/isolation-levels/</url>
      
        <content type="html"><![CDATA[<p>In this article we will talk about <strong>isolation levels</strong> in RDBMS</p><p>​    If multiple transactions do not process the same data, they can run safely in parallel. Race conditions becomes inevitable when one transaction process data that is modyfied by another transaction. </p><p>​    That is why it’s important to deal properly in this situation. The strongest level of consistency that could provide database - <strong>serializable isolation level.</strong> It’s like sequential running transactions if they share some data in database. How we can  achieve that level? Just simply put locks on data that we have read or write. And no one can access data while we unlock that data. It means no one can access data and there are a wait look on it, after data was unlocked transation take process data. If we use such approach for every transcations that we run in database we get big performance issue. And for this purposes there are exists  another weak levels of isolations that could give guarantes with conditions to process transactions.  </p><p><strong>Read commited</strong></p><p>​    The default level in many databases that gives you two guarantees. Transaction reads only commit data. It’s impossible to read data that was uncommit. For example in case when you some transaction start modifying data and at some moment of time get aborted. There is no middle time transaction that was read uncommited data that was never existed. Another synonym for this - <strong>no dirty reads</strong>. The same works for writes. You never write data that wasn’t commited, <strong>no drity writes.</strong> Implementing no dirty writes like putting lock on data before modyfing data. It must wait until lock asquired before modifying data. Most databases stores old and new value of data to prevent dirty writes. </p><p><strong>Repeatable read</strong></p><p>​    Suppose you two have account in bank with 500$ on each. And you wanna get total sum of your money. You read first accont and get 500$. At this point of time another transactions start transfer 100$ from one account to another. Transaction increments first account by 100$ and decrements by 100$ on second account and commited succefully. You continue reading second account money and get 400$ in it. So totally you get 900$, but in fact it must be 1000$. This phenomenon names non repeatable read. And Repeatable read isolation level guarantees to you to escape <strong>non repeatable read</strong>. To implement this behaviour you need to keep snapshot isolation in your database, that also relates to storing different versions of your data**(MVCC)** while transactions are running under this level. Every transaction has it’s own auto incrementing id. And transactions can differentiate data by applying knowledge from this ids. </p><p>​    Both levels don’t prevent from <strong>lost update,</strong> that happens when you need read value, modify it and save back. If two transcation do this concurenly you will probably lose one of the modification, because some transaction don’t consider first modification and rewrite value. For this problem there are several solutions: </p><p><strong>Atomic write</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> counters <span class="keyword">SET</span> <span class="keyword">value</span> <span class="operator">=</span> <span class="keyword">value</span> <span class="operator">+</span> <span class="number">1</span> <span class="keyword">WHERE</span> key <span class="operator">=</span> <span class="string">&#x27;foo&#x27;</span>;</span><br></pre></td></tr></table></figure><p>In given query database setup exclusive lock on value, so that no one can access value while it inrements it. </p><p>Another way to use <strong>explicit lock</strong>: </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACTION;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> figures</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;robot&#x27;</span> <span class="keyword">AND</span> game_id <span class="operator">=</span> <span class="number">222</span></span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="comment">-- Check whether move is valid, then update the position</span></span><br><span class="line"><span class="comment">-- of the piece that was returned by the previous SELECT.</span></span><br><span class="line"><span class="keyword">UPDATE</span> figures <span class="keyword">SET</span> position <span class="operator">=</span> <span class="string">&#x27;c4&#x27;</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1234</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>The key for lock is <code>FOR UPDATE</code> statements, that locks rows and other transactions considering this rows waits until lock is released. </p><p><strong>Automatically detecting lost update</strong> is one of the the way to deal sutuation. In this case database automatically find losted updates and abort transaction or give another try again. </p><p>If you don’t use transactions it’s possible to prevent lost update by doing <strong>compare and set</strong>: </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> wiki_pages <span class="keyword">SET</span> content <span class="operator">=</span> <span class="string">&#x27;new content&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1234</span> <span class="keyword">AND</span> content <span class="operator">=</span> <span class="string">&#x27;old content&#x27;</span>;</span><br></pre></td></tr></table></figure><p>Keep in mind to handle situation when you need to try again if no updates happened. </p><p><strong>Phantoms</strong> phenomena can’t also be preveneted by applying given isolation levels. Phantoms happens when you consider data that can’t be attached to some lock in database, for example while registering in service, you select accounts with given username and if there is no accounts you create account and concurrent transaction could also successfully repeat actions. </p><p><strong>Serializable isolation</strong></p><p>The strongest form of guarantee. There are 3 ways to implement this:</p><ol><li>Serial processing of transactions </li><li>Two phase locking </li><li>Optimistic concurrency control </li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ACID</title>
      <link href="2021/02/02/acid/"/>
      <url>2021/02/02/acid/</url>
      
        <content type="html"><![CDATA[<p>The safety guarantees provided by transactions are often know as acronym <strong>ACID</strong>, that stands for <strong>Atomacity, Consistency, Isolation and Durabilty</strong>. It’s important to differentiate from <strong>BASE</strong> acronym which stands for Basically Available Soft State, Eventual consistency. ACID relates to transactions, while BASE it’s more about system. Let’s describe each letter sequentially.</p><p><strong>Atomacity</strong></p><p>​    Imagine situation where you wanna send a multiple write queries to database and unfortunately something bad happened between query processing. Process crashes or network interrrupt or someone unplug electrical cable. How you fix this situation? Send write queries again? This thing can happen everywhere and every time, that is why transcations provide such a good thing atomaticy. Something that you can’t break into smaller parts and processed by database like a one query. By this property possible solution would be to abord all writes within this transaction. And if run your database after crash transation would be reject as not completed. This works by transcation journal.  </p><p><strong>Consistency</strong></p><p>​    Atomacity, durability, isolation - properties of database, while consistency - property of application. It’s up to you to decided wether you application in consistent way or not. And you can relate to ACID properties as an ultimate truth to stay your data consistent. </p><p><strong>Isolation</strong></p><p>​    Databases are concurrent. It’s often happens when transactions processes concurently and if some transcation will see middle results of another transaction that could be aborted or commited we can get wrong results by condsidering not commited results. And for this case isolation make possible to run transaction like a single transcation in database at current time. It’s like sequential running of transactions, while databases uses MVCC to bring isolation between transactions. </p><p><strong>Durability</strong></p><p>​    This property ensures that once transcation was completed the data will be completely saved even if system crash happens. For single node database it would be a promise to write data for non volatile storage, in replicated database it could mean that the data was completely copied to all nodes. </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LCS Dynamic Programming</title>
      <link href="2021/02/01/lcs-dynamic/"/>
      <url>2021/02/01/lcs-dynamic/</url>
      
        <content type="html"><![CDATA[<p>In this article we will talk about Longest Common Sunsequence.<br>Given next problem:<br><em>Given two words word1 and word2, find the minimum number of steps required to make word1 and word2 the same, where in each step you can delete one character in either string.</em></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example</span><br><span class="line">Input: &quot;sea&quot;, &quot;eat&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: You need one step to make &quot;sea&quot; to &quot;ea&quot; and another step to make &quot;eat&quot; to &quot;ea&quot;.</span><br></pre></td></tr></table></figure><p>Intuitively we get recursive solution. Lets define next function:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcs</span><span class="params">(String s1, String s2, <span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span> </span></span><br></pre></td></tr></table></figure><p>Function returns the common longest subsequence for strings s1 and s2 with corresponding length n1 and n2.</p><ol><li>Base case would be when n1 or n2 equals to zero, in this case longest common subsequence of empty and not empty strings would be empty string. Return value would be <code>0</code>.</li><li>There are two cases exists:<ol><li><code>s1.charAt(n1 - 1) == s2.charAt(n2 - 1).</code> In this case we know that given strings of size n1 and n2 has two same chars at positions n1 - 1 and n2 - 1. And all we need to do is to find common subseqence of strings n1 - 1, n2 - 1. Return value would be <code>1 + lcs(s1, s2, n1 - 1, n2 - 1)</code></li><li><code>s1.charAt(n1 - 1) != s2.charAt(n2 - 1).</code>In this case we can conlcude that common subsequence could end at index n1 - 1 or n2 - 1. That is why we need to check both cases and select maximum common subsequence. Return value would be <code> Math.min(lcs(s1,s2,n1,n2-1), lcs(s2,s2,n1-1,n2);</code></li></ol></li></ol><p>Lets combine this into one function:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lcs</span><span class="params">(String s1, String s2, <span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n1 == <span class="number">0</span> || n2 == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (s1.charAt(n1-<span class="number">1</span>) == s2.charAt(n2-<span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + lcs(s1,s2, n1-<span class="number">1</span>, n2-<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(lcs(s1,s2,n1-<span class="number">1</span>,n2),lcs(s1,s2,n1,n2-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Keep in mind: we need substract double length of lcs from sum of length of strings. Because the statement is to find minimum number of chars to delete to get equal strings. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;sea&quot;</span>, s2 = <span class="string">&quot;eat&quot;</span>;</span><br><span class="line">        System.out.format(<span class="string">&quot;Ans is %d&quot;</span>, minDelete(s1,s2));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minDelete</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = s1.length(), n2 = s2.length();</span><br><span class="line">        <span class="keyword">return</span> n1 + n2 - <span class="number">2</span> * lcs(s1,s2,n1,n2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lcs</span><span class="params">(String s1, String s2, <span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n1 == <span class="number">0</span> || n2 == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (s1.charAt(n1-<span class="number">1</span>) == s2.charAt(n2-<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + lcs(s1,s2, n1-<span class="number">1</span>, n2-<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(lcs(s1,s2,n1-<span class="number">1</span>,n2),lcs(s1,s2,n1,n2-<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Let’s optimize algorithm. Recursion calls itself again and again, and instead of getting values from recursion we can cache answers and use it later. Cache would be simple two dimensional array of size n1 + 1, n2 + 1, that holds Integers. If <code>cache[i][j] != null</code> then cache holds precomputed value, otherwise compute and update cache.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minDelete</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n1 = s1.length(), n2 = s2.length();</span><br><span class="line">    Integer[][] cache = <span class="keyword">new</span> Integer[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> n1 + n2 - <span class="number">2</span> * lcs(cache, s1,s2,n1,n2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lcs</span><span class="params">(Integer [][] cache, String s1, String s2, <span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cache[n1][n2] != <span class="keyword">null</span>) <span class="keyword">return</span> cache[n1][n2];</span><br><span class="line">    <span class="keyword">if</span> (n1 == <span class="number">0</span> || n2 == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="keyword">if</span> (s1.charAt(n1-<span class="number">1</span>) == s2.charAt(n2-<span class="number">1</span>)) &#123;</span><br><span class="line">        ans = <span class="number">1</span> + lcs(cache, s1,s2, n1-<span class="number">1</span>, n2-<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ans = Math.max(lcs(cache, s1,s2,n1-<span class="number">1</span>,n2),lcs(cache, s1,s2,n1,n2-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache[n1][n2] = ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We can break algorithm if we provide big strings that gives overflow of stack. It has place to make iterative solution. The idea remains the same. If current chars <code>i, j</code> are same we have got new longest subsequence at path <code>cache[i][j]</code>, if not then the answer would be the biggest value between <code>cache[i][j-1]</code> and <code>cache[i-1][j]</code>(don’t forget to change <code>Integer[][]cache -&gt; int[][]cache</code>).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static int lcs(int [][] cache, String s1, String s2, int n1, int n2) &#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt;&#x3D; n1; ++i) &#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt;&#x3D; n2; ++j) &#123;</span><br><span class="line">            if (i &#x3D;&#x3D; 0 || j &#x3D;&#x3D; 0) continue;</span><br><span class="line">            if (s1.charAt(i - 1) &#x3D;&#x3D; s2.charAt(j - 1)) &#123;</span><br><span class="line">                cache[i][j] &#x3D; 1 + cache[i-1][j-1];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cache[i][j] &#x3D; Math.max(cache[i][j-1], cache[i-1][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return cache[n1][n2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Union Find</title>
      <link href="2021/02/01/union-find/"/>
      <url>2021/02/01/union-find/</url>
      
        <content type="html"><![CDATA[<p>In this article we will talk about <strong>Union Find.</strong></p><p>Let’s imagine that we have set of N elements, and some elements are connected. Elements that are connected produce some subset. Your question is to find number of distinct subsets or to find set with maximum number of members.</p><p><strong>Case #1</strong><br><em>There are n cities and k connections. Connected cities(directly or indirectly) declares province. Find total number of province.</em></p><p>Constraints: </p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= n &lt;= 10000</span><br><span class="line">arr[s] = [i,j]; 1 &lt;= i,j &lt;= n, i != j, [i,j] - unique pairs</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Example #1 </span><br><span class="line">Input: </span><br><span class="line">10 </span><br><span class="line">[[1,2], [1,3], [2,5], [7,8], [5, 6], [9,10]]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p>From example above you can see that provinces are:</p><ul><li>1, 2, 3, 5, 6</li><li>4</li><li>7, 8 </li><li>9, 10</li></ul><p>In total we have 4 provinces. </p><p>Efficient approach to solve this problem is to use Union Find DS. The main idea is</p><ol><li><p>Create unique ids array for each element in set. It means if we have 10 elements in set, unique ids are nums[1,2,3,4,5,6,7,8,9,10]. </p></li><li><p>Define root element. Root element is an element where nums[i] = i. Initially all elements are roots. We have 10 roots. If we have nums = [1, 1, 1, 1, 5, 5, 5, 5, 9, 10], it means root elements are 1, 5, 9, 10, moreover if we have nums = [1, 1, 1, 1, 1, 1, 5, 5, 9, 10], then root elements are 1, 9, 10 (because nums[5] =1)</p></li><li><p>Implement “find” function. “Find” function searches root of element.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">while</span>(nums[i] != i) &#123;</span><br><span class="line">          i = nums[i];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Implement union function. Union function connect to elements. How do we do this? Find root of first element(root1), find root of second element(root2). Setup nums[root1] = root2</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> rootI = find(nums, i);</span><br><span class="line">       <span class="keyword">int</span> rootJ = find(nums, j);</span><br><span class="line">       nums[rootI] = rootJ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Let’s define final algorithm for the question:</p><ol><li>Create unique ids array(nums)</li><li>Iterate through connection array and union cities </li><li>Find total number of roots in nums. </li></ol><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> [][] connections = <span class="keyword">new</span> <span class="keyword">int</span> [][] &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;, &#123;<span class="number">1</span>,<span class="number">3</span>&#125;, &#123;<span class="number">2</span>,<span class="number">5</span>&#125;, &#123;<span class="number">7</span>,<span class="number">8</span>&#125;, &#123;<span class="number">5</span>,<span class="number">6</span>&#125;, &#123;<span class="number">9</span>,<span class="number">10</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> ans = numberOfProvince(n, connections);</span><br><span class="line">        System.out.format(<span class="string">&quot;Number of provinces - %d&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(nums[i] != i) &#123;</span><br><span class="line">            i = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootI = find(nums, i);</span><br><span class="line">        <span class="keyword">int</span> rootJ = find(nums, j);</span><br><span class="line">        nums[rootI] = rootJ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numberOfProvince</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] connections)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span> [n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            nums[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] conn: connections) &#123;</span><br><span class="line">            union(nums, conn[<span class="number">0</span>], conn[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; roots = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> currRoot = find(nums, i);</span><br><span class="line">            roots.add(currRoot);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> roots.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Case #2</strong></p><p><em>Given an unsorted array of integers arr, find the length of longest consucutive elements sequence.</em> </p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Example #1</span><br><span class="line">Input: nums = [100,4,200,1,3,2]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.</span><br><span class="line"></span><br><span class="line">Example #2</span><br><span class="line">Input: nums = [0,3,7,2,5,8,4,6,0,1]</span><br><span class="line">Output: 9</span><br></pre></td></tr></table></figure><p>If you think about this problem in Union Find way, you can get that all consecutive elements sequece define some subset(connected component) and all we need to do is to find the biggest one. In general we need to iterate through array and try to union elements (val, val + 1) and (val, val - 1) if they given. It means we need to know whether there exists values (val + 1) or (val - 1) in order to retrive their indexes. This can be done via projecting values to indexes. Map would be effecient way. What happens if you have duplicates? Actually it doesn’t matter, because we store only the last occurence of value in map and we need keep in mind to process indexes that are exists in map. How we can get maximum size set? We can create another array counter, that will keep track size of each root’s set.</p><p>Solution: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] arr = <span class="keyword">new</span> <span class="keyword">int</span> [] &#123;<span class="number">100</span>,<span class="number">4</span>,<span class="number">200</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> ans = longestConsecutive(arr);</span><br><span class="line">        System.out.format(<span class="string">&quot;Longest sequence size - %d&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(nums[i] != i) &#123;</span><br><span class="line">            i = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootI = find(nums, i);</span><br><span class="line">        <span class="keyword">int</span> rootJ = find(nums, j);</span><br><span class="line">        nums[rootI] = rootJ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> [] nums = <span class="keyword">new</span> <span class="keyword">int</span> [n];</span><br><span class="line">        Map&lt;Integer, Integer&gt; mp = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;++i) &#123;</span><br><span class="line">            nums[i] = i;</span><br><span class="line">            mp.put(arr[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mp.get(arr[i]) != i) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> prev = arr[i] - <span class="number">1</span>, next = arr[i] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (mp.containsKey(prev)) &#123;</span><br><span class="line">                union(nums, i, mp.get(prev));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mp.containsKey(next))  &#123;</span><br><span class="line">                union(nums, i, mp.get(next));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> [] counter = <span class="keyword">new</span> <span class="keyword">int</span> [n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> currRoot = find(nums, i);</span><br><span class="line">            ans = Math.max(ans, ++counter[currRoot]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Both problems can be found in leetcode.com.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Major element in array</title>
      <link href="2021/01/31/major-element/"/>
      <url>2021/01/31/major-element/</url>
      
        <content type="html"><![CDATA[<p>In this article we will talk about finding <strong>majority element</strong> in array. </p><p>Major element is an element that apeears in array more than half of array size times.</p><p>If you think about brute force solution, you can get this by doing O(n<sup>2</sup>) time complexity, meanwhile there are exists linear complexity solution named <strong>Moore’s Voting Algorithm.</strong></p><p>The basic idea is simple. Setup current major element as first element in array and created variable counter with value 1. Iterate through array and increment counter by one if current value in array equals to current major element, otherwise decrement counter. If counter equals to zero, then current element in array would be a new major element and setup counter to 1. </p><p>After end of loop count major element in array, if there are more than half of array size repetitions, that element is <strong>major element</strong>, otherwise there is no major element.</p><p>Algorithm:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] arr = <span class="keyword">new</span> <span class="keyword">int</span> [] &#123;<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">55</span>,<span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> ans = majorElement(arr);</span><br><span class="line">            System.out.format(<span class="string">&quot;Major element is %d&quot;</span>, ans);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception err) &#123;</span><br><span class="line">            System.err.println(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">majorElement</span><span class="params">(<span class="keyword">int</span>[] arr)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">int</span> ans = arr[<span class="number">0</span>], counter = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans == arr[i])</span><br><span class="line">                counter++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                counter--;</span><br><span class="line">            <span class="keyword">if</span> (counter == <span class="number">0</span>) &#123;</span><br><span class="line">                counter = <span class="number">1</span>;</span><br><span class="line">                ans = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == ans)</span><br><span class="line">                count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; n / <span class="number">2</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;No major element&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
